@model classwork1.Models.RazorModel
@{
    ViewData["Title"] = "Razor";
}

<div>
    <h1 class="display-4">Огляд Razor</h1>
</div>
<p>
    Razor - синтаксична варіація C# для використання у представленнях.
</p>

<h3>Виведення даних</h3>
<p>
    Для виведення змінної достатньо перед неї зазначити символ &commat;,
    наприклад <code>&commat;Model.IntValue = @Model.IntValue</code>.
    Особливість Razor у тому, що він намагається самостійно визначити
    межі інструкції. У простих виразах йому це вдається, але не завжди.
    Наприклад: <code>&commat;Model.IntValue + 1 = @Model.IntValue + 1</code>
    У такому разі вживається конструкція &commat;(...) 
    <code>&commat;(Model.IntValue + 1) = @(Model.IntValue + 1)</code>
</p>

<h3>Блоки коду</h3>
<p>
    Інструкції, які не потрібно виводити, оточуються &commat;{...}.
    Це ніяк не відбивається на вигляді сторінки, такі блоки для відображення
    не беруть участь. У них допустимі довільні інструкції C#, у т.ч. введення 
    нових змінних. Після інструкції
    <code>
        &commat;{ int y = 20; }
    </code>
    @{
        int y = 20;
    }
    Можна вивести нову змінну <code>&commat;y = @y</code>
</p>

<h3>Умовна верстка</h3>
<p>
    Razor довзволяє включати (чи не включати) певні частини HTML в залежності
    від програмних умов. Для цього вживається &commat;if{...}<br />
    Блок, що не проходить умову, не включається до HTML жодним чином,
    його просто не існує в HTML. Аналогічним чином працює &commat;switch(){...}
</p>
@if(Model.BoolValue) 
{
    <p>Цей блок буде видно, якщо Model.BoolValue буде true</p>
}
else
{
    <p>Цей блок буде видно, якщо Model.BoolValue буде false</p>
}
<p>Та ж особливість (автоматичного визначення) дозволяє "змішувати" програмні інструкції
    та розмітку. Для уникнення помилок усю розмітку бажано оточувати тегами.
</p>
<code>
    <code>
        &commat;if (Model.BoolValue)<br />
        {<br />
        &nbsp; &nbsp; int w = 30;  <strong>// Це інструкція</strong><br />
        &nbsp; &nbsp; &lt;p>Цей блок буде видно, ...&lt;/p>  <strong>// Це верстка</strong><br />
        &nbsp; &nbsp; w += 10;  <strong>// Це інструкція</strong> <br />
        &nbsp; &nbsp; &lt;span>У даному місці w = &commat;w &lt;span>  <strong>// Це верстка</strong><br />
        &nbsp; &nbsp; Щось друкуємо без тегу  <strong>// Це помилка, сприймається як код</strong><br />
        }<br />
    </code>
</code>

<h3>Циклічна верстка</h3>
<p>
    Цикли у Razor є всі: &commat;for(){}, &commat;while(){},
    &commat;do{}while(),&commat;foreach(){}.
    Блоки верстки, що є у тілах цих циклів повторюються у HTML. Це дозволяє
    яяк створювати набори блоків, так і формувати складені теги, на кшталт
    таблиць чи переліків.
</p>
@for(int i = 0; i < Model.ListValue.Count; ++i)
{
    <h6>@(Model.ListValue[i])</h6>
}
<ol>
    @foreach(String item in Model.ListValue)
    {
        <li>@item</li>
    }
</ol>

<p>
    Сучасна рекомендація - не використовувати у Razor-представленнях
    кодові засоби окрім формування виведення (не звертатись до БД,
    не передавати об'єкти за посиланнями, не використовувати службу часу
    чи перетворення рядків.) Це дозволить "відокремити" представлення -
    перенести його у фронтенд (у т.ч. до мобільного чи десктопного застосунку).
    Всі обчислення - у контроллері, представлення лише "розкладає" дані
    по візуальним блокам.
</p>

<table>
    <tr>
        <th>Num</th>
        <th>Value</th>
    </tr>
    @for (int i = 0; i < Model.ListValue.Count; ++i)
    {
        <tr>
            <td>@(i + 1)</td>
            <td>@(Model.ListValue[i])</td>
        </tr>
    }
</table>