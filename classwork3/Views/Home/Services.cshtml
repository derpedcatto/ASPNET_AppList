@inject classwork3.Services.Hash.IHashService hashService
@{
    ViewData["Title"] = "Services";
}

<div class="text-center">
    <h1 class="display-4">Служби та інжекція залежностей</h1>
</div>

<p>
    Служби - "постачальники" об'єктів, які керують їх життєвим циклом.
    Служби приходять на заміну інструкціям на кшталт 
    <code>var instance = new FunctionalClass()</code>,
    які кожного разу утворюють нові об'єкти.
    Якщо у різних частинах проєкту потрібні однакові об'єкти і немає
    необхідності кожного разу створювати новий, то служби - це рішення.
</p>
<p>
    Створення служби складається з кількох етапів:
</p>
<ol>
    <li>Оголошуємо необхідні класи</li>
    <li>Реєструємо службу у Program.cs(<code>builder.Services.Add...</code>)</li>
    <li>Інжектуємо службу у потрібне місце.</li>
</ol>
<p>
    У вимогах SOLI<b>D</b> наявний принцип DIP - Dependency Inversion Principle,
    згідно з яким залежності не бажано утворювати від класів (реалізації),
    а краще посилатись на інтерфейси (абстракції). Зокрема, це дозволяє у простий спосіб
    змінювати реалізації без змін точок інжекції:<br />
    Інжекція через клас: <code>Hasher hasher</code><br />
    Інжекція через інтерфейс: <code>IHasher hasher</code><br />
    Різниця відчувається тоді, коли виходить "нова версія" NewHasher:
    у першому варіанті доведеться змінювати усі точки, де є код <code>Hasher hasher</code>,
    тоді як у другому нічого змінювати не доведеться, якщо NewHasher реалізує інтерфейс IHasher.
</p>
<p>
    Для організації коду служби оголошують в окремій папці Services,
    оскільки кожна служба це щонайменше 2 файли (інтерфейс та клас),
    кожну службу теж реалізують в окремій папці.
</p>
<p>
    Створюємо інтерфейс <code>IHashService</code> та його реалізація <code>Md5HashService</code>
    Реєструємо дану службу - відповідність інтерфейсу та реалізації.
    <code>builder.Services.AddSingleton<IHashService, Md5HashService>();</code>
    Цю інструкцію можна тлумачити як "будуть питати IHashService - видати об'єект Md5HashService"
</p>
<p>
    Впровадження (інжекція) служби - у контроллері <br />
    <code>private readonly IHashService _hashService;</code>
    Та додаємо параметр у конструктор, це можна зробити через помічника (оперативне меню).
    Далі використовуємо:
    <code>_hashService.HashString("123");</code> = @ViewData["hash"]
    Служби також можна інжектувати у представлення (View), хоча це украй не рекомендується.
    <code>&commat;inject classwork3.Services.Hash.IHashService hashService</code>
</p>
<p>
    Вносимо зміни - утворюємо ще один класс <code>Sha1HashService</code>
    та змінюємо у Program.cs реєсттрацію служби
    <code>builder.Services.AddSingleton<IHashService, Sha1HashService>();</code>
    Інших змін у код вносити не треба, всі точки інжекції автоматично перейдуть на роботу 
    з новою реалізацією.
</p>
<p>
    Scope - область існування об'єктів (служб). Це область життєвого циклу програми, у якій об'єкт
    існує без змін, при виході з цієї області буде створюватись новий об'єкт. Можна порівняти 
    з локальністю (областю видності) змінних, але scope служб має часові особливості.
</p>
<p>
    <b>Singleton</b> - постійне існування протягом усього "життя" програми. Для контролю за створенням
    нових об'єктів можна досліджувати їх внутрішній геш-образи (HashCode):
    код у контроллері - @ViewData["obj"]
    код у представленні - @hashService.GetHashCode()
</p>
<p>
    <b>Scoped</b> - існування протягом оброблення одного запиту (RequestScoped).
    код у контроллері - @ViewData["obj"]
    код у представленні - @hashService.GetHashCode()
</p>
<p>
    <b>Transient</b> - утворення нових об'єктів для кожної з точок інжекції.
    код у контроллері - @ViewData["obj"]
    код у представленні - @hashService.GetHashCode()
</p>
<p>
    HashCode Controller: @ViewData["ctr"]
</p>